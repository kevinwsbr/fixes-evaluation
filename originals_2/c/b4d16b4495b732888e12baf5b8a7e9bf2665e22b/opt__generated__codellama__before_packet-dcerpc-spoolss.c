[PYTHON]
# This file is generated by /home/kwang/Desktop/dcerpc_wsdlg/generate.py, do not modify directly!
from __future__ import absolute_import, unicode_literals
from apex_2018.utils.dcerpc import DCERPC

# dcerpc-spoolss: 6.1.7601.17514 (win7-sp1)

class DCERPCDcerpcSpoolss(DCERPC):
    ATTACHMENT_ID = 'dcerpc-spoolss'
    SERVICE_NAME = 'spoolss'
    OPTIONAL_PROTOCOLS = ['ncacn_ip_tcp']
    DEFAULT_PROTOCOL = 'ncacn_np'
    DEFAULT_ATTACHMENT_ID = ATTACHMENT_ID + '-' + DEFAULT_PROTOCOL
    DCERPC_UUID = uuid.UUID('12345678-1234-abcd-ef00-0123456789ab')
    DCERPC_IFACE_UUIDS = { '6.1': [uuid.UUID('ba97719a-28e7-418f-b7be-5c450bbd7df3')] }

    def __init__(self, context):
        super(DCERPCDcerpcSpoolss, self).__init__(context)
        self.context = context
        self.name = 'dcerpc-spoolss'

    def init_proto(self):
        self.request = dcerpc.DCERPCRequest()
        self.response = dcerpc.DCERPCResponse()

        self.request.opnum = -1
        self.response.stubdata = b''

        self.init_type_maps()

    def init_type_maps(self):
        # SID
        # 2b 05 [4 byte rid] [1 byte auth] [1 byte authnz]

        # SECURITY_DESCRIPTOR
        # 0c 00 [pointer: 4 bytes]

        # SECURITY_DESCRIPTOR_RELATIVE
        # 0c 01 [pointer: 2 bytes]

        self.type_map = {
            '8b03': ('SID', 12),
            'beef': ('SECURITY_DESCRIPTOR', 4),
            'befa': ('SECURITY_DESCRIPTOR_RELATIVE', 2)
        }

    def get_attachment_id(self):
        return self.context.get_attachment_id(self.ATTACHMENT_ID)

    def init_dcerpc(self, protocol='ncacn_np'):
        # We'll always use the DEFAULT_PROTOCOL first, as that is what most services use
        if self.DEFAULT_PROTOCOL in self.OPTIONAL_PROTOCOLS and self.DEFAULT_ATTACHMENT_ID not in self.context.attachment_ids:
            protocol = self.DEFAULT_PROTOCOL
            self.get_attachment_id()

        # If it's not DEFAULT_PROTOCOL, try to attach with the protocol specified as an argument
        if protocol != self.DEFAULT_PROTOCOL and protocol in self.OPTIONAL_PROTOCOLS:
            self.get_attachment_id(protocol)

        return self.context.dcerpc.init_rpc(self, self.DCERPC_UUID, protocol=protocol)

    def init_request(self):
        self.request = dcerpc.DCERPCRequest()
        self.request.stubdata = b''

    def init_response(self):
        self.response = dcerpc.DCERPCResponse()
        self.response.stubdata = b''

    def set_opnum(self, opnum=0):
        self.request.opnum = opnum

    def send_recv(self, request=None, attachment_id=None, timeout=10):
        if not request:
            request = self.request
        if not attachment_id:
            attachment_id = self.get_attachment_id()
        return self.context.dcerpc.send_recv(self, request, attachment_id, timeout)

    def call(self, function, request=None):
        self.set_opnum(function)
        self.init_request()
        self.set_parameters(request)
        return self.send_recv()

    def set_parameters(self, parameters=b''):
        # We'll always use the DEFAULT_PROTOCOL first, as that is what most services use
        if self.DEFAULT_PROTOCOL in self.OPTIONAL_PROTOCOLS and self.DEFAULT_ATTACHMENT_ID not in self.context.attachment_ids:
            parameters = dcerpc.DCERPCBinaryParser().get_dword(parameters) + b'\x01\x00\x00\x00' + parameters
        # If it's not DEFAULT_PROTOCOL, try to attach with the protocol specified as an argument
        elif self.DEFAULT_PROTOCOL != 'ncacn_np':
            if 'ncacn_ip_tcp' in self.OPTIONAL_PROTOCOLS:
                parameters = dcerpc.DCERPCBinaryParser().get_dword(parameters) + b'\x02\x00\x00\x00' + parameters
            elif 'ncacn_np' in self.OPTIONAL_PROTOCOLS:
                parameters = dcerpc.DCERPCBinaryParser().get_dword(parameters) + b'\x01\x00\x00\x00' + parameters

        # Check for SIDs
        if type(parameters) == bytes and len(parameters) > 0 and parameters[0] == ord('8'):
            parser = dcerpc.DCERPCBinaryParser()
            offset = 0
            while offset < len(parameters):
                try:
                    sid_len = parser.get_uint16(parameters, offset + 2)
                    offset += sid_len
                except Exception as e:
                    break
        self.request.stubdata = parameters

    def get_parameters(self):
        return self.request.stubdata

    def get_entrypoint_id(self, entrypoint='AddPrinterConnection'):
        if self.DEFAULT_PROTOCOL in self.OPTIONAL_PROTOCOLS and self.DEFAULT_ATTACHMENT_ID not in self.context.attachment_ids:
            return 0x21d8
        elif 'ncacn_ip_tcp' in self.OPTIONAL_PROTOCOLS:
            if entrypoint == 'AddPrinterConnection':
                return 0xe16b
            elif entrypoint == 'GetPrinterDriverDirectory':
                return 0x274a
            elif entrypoint == 'GetPrinterDataEx':
                return 0xc59c
        elif 'ncacn_np' in self.OPTIONAL_PROTOCOLS:
            if entrypoint == 'AddPrinterConnection':
                return 0x21d8
            elif entrypoint == 'GetPrinterDriverDirectory':
                return 0x3572
            elif entrypoint == 'GetPrinterDataEx':
                return 0xb968
        else:
            raise Exception('No available protocols to call the function')

    def get_parameters(self):
        parameters = {}

        # Check for SIDs
        if type(self.request.stubdata) == bytes and len(self.request.stubdata) > 0:
            parser = dcerpc.DCERPCBinaryParser()
            offset = 0
            while offset < len(self.request.stubdata):
                try:
                    sid_len = parser.get_uint16(self.request.stubdata, offset + 2)
                    sid_str = 'SID(' + str(parser.get_dword(self.request.stubdata, offset)) + ')'
                    parameters[sid_str] = parser.get_bytes(self.request.stubdata, offset + 4, sid_len)
                    offset += sid_len
                except Exception as e:
                    break

        return parameters

    def get_return(self):
        if type(self.response.stubdata) == bytes and len(self.response.stubdata) > 0:
            parser = dcerpc.DCERPCBinaryParser()
            offset = 0
            try:
                errorcode = parser.get_uint32(self.response.stubdata, offset)
                if errorcode == 0:
                    offset += 4
                    returncode = parser.get_dword(self.response.stubdata, offset)
                    parameters = {}
                    if returncode == 2187939203:
                        return 'ERROR_SUCCESS'
                    elif returncode == 1510567936:
                        return 'PRINTER_STATUS_PAUSED'
                    elif returncode == 1510568481:
                        return 'PRINTER_STATUS_ERROR'
                    elif returncode == 2187941016:
                        return 'PRINTER_STATUS_PENDING_DELETION'
                    elif returncode == 1510570793:
                        return 'PRINTER_STATUS_PAPER_JAM'
                    elif returncode == 2187941568:
                        return 'PRINTER_STATUS_OFFLINE'
                    elif returncode == 1510571392:
                        return 'PRINTER_STATUS_BUSY'
                    elif returncode == 2187942144:
                        return 'PRINTER_STATUS_INITIALIZING'
                    elif returncode == 1510572064:
                        return 'PRINTER_STATUS_WARMING_UP'
                    elif returncode == 2187942736:
                        return 'PRINTER_STATUS_TONER_LOW'
                    elif returncode == 1510572688:
                        return 'PRINTER_STATUS_NO_TONER'
                    elif returncode == 2187943328:
                        return 'PRINTER_STATUS_DOOR_OPEN'
                    elif returncode == 1510573168:
                        return 'PRINTER_STATUS_USER_INTERVENTION_REQUIRED'
                    elif returncode == 2187943904:
                        return 'PRINTER_STATUS_OUTPUT_BIN_FULL'
                    elif returncode == 1510573632:
                        return 'PRINTER_STATUS_NOT_AVAILABLE'
                    elif returncode == 2187944480:
                        return 'PRINTER_STATUS_nOPRINTING'
                    elif returncode == 1510574208:
                        return 'PRINTER_STATUS_WAITING_ON_USER_ACTIVITY'
                    elif returncode == 2187944976:
                        return 'PRINTER_STATUS_POWER_SAVE'
                    else:
                        parameters['UnknownStatusCode'] = parser.get_dword(self.response.stubdata, offset)
                elif errorcode == 2147746089:
                    return 'RPC_S_CALL_FAILED'
            except Exception as e:
                pass

        return self.response.stubdata

# DCE/RPC Connection
class DCERPCConection():

    def __init__(self, context, connection):
        self.context = context
        self.connection = connection

    def send_recv(self, function, request=b''):
        try:
            stubdata = function.get_parameters()
            # Check if we need to add a SID
            if type(stubdata) == dict and 'SID' in stubdata:
                sid_len = dcerpc.DCERPCBinaryParser().get_uint16(stubdata['SID'], 0) + 4
                stubdata['SID'] = dcerpc.DCERPCBinaryParser().get_dword(sid_len) + sid_len.to_bytes(2, byteorder='little') + stubdata['SID']
            request = function.request(stubdata).encode('utf-8')
        except Exception as e:
            self.context.log.error("Error while building request: %s" % (e))
            return None

        try:
            response = self.connection.send_recv(request)
        except Exception as e:
            self.context.log.error("Error while sending/receiving request: %s" % (e))
            return None

        if response is not None:
            try:
                response = response.decode('utf-8')
            except Exception as e:
                pass

            try:
                response = function.response(response).params['Buffer']
            except Exception as e:
                self.context.log.error("Error while parsing response: %s" % (e))
                return None

        return response